-- ======= RESET (borra y recrea) ==========================================
begin;

-- 0) Borrar objetos dependientes en orden correcto
drop trigger if exists trg_reviews_after_change on reviews;
drop function if exists recompute_place_rating();

drop table if exists itinerary_items cascade;
drop table if exists itineraries cascade;
drop table if exists visits cascade;
drop table if exists favorites cascade;
drop table if exists review_likes cascade;
drop table if exists reviews cascade;
drop table if exists place_photos cascade;
drop table if exists place_hours cascade;
drop table if exists place_subcategories cascade;
drop table if exists places cascade;
drop table if exists subcategories cascade;
drop table if exists categories cascade;
drop table if exists countries cascade;
drop table if exists app_users cascade;

commit;

-- ======= CREACIÓN ========================================================
-- Extensión recomendada para UUID en Supabase
create extension if not exists pgcrypto;

-- 1) Catálogos básicos
create table countries (
  country_id  serial primary key,
  name        varchar(100) not null,
  iso_code    varchar(3)   not null unique
);

create table categories (
  category_id serial primary key,
  name        varchar(60)  not null unique
);

create table subcategories (
  subcategory_id serial primary key,
  category_id    int not null references categories(category_id) on delete cascade,
  name           varchar(80) not null,
  unique (category_id, name)
);

-- 2) Usuarios (tabla propia; si querés usar auth.users, avisá y la conectamos)
create table app_users (
  user_id    uuid primary key default gen_random_uuid(),
  name       varchar(120),
  email      varchar(160) unique,
  photo_url  text,
  provider   varchar(20) not null default 'guest',
  is_guest   boolean not null default true,
  created_at timestamp not null default now(),
  constraint chk_provider check (provider in ('google','guest','email'))
);

-- 3) Lugares (POIs)
create table places (
  place_id       uuid primary key default gen_random_uuid(),
  name           varchar(160) not null,
  description    text,
  address        varchar(200),
  city           varchar(100),
  country_id     int not null references countries(country_id),
  latitude       numeric(9,6),
  longitude      numeric(9,6),
  google_maps_url text,
  website_url    text,
  phone          varchar(40),
  created_by     uuid references app_users(user_id),
  avg_rating     numeric(3,2) default 0.00,
  review_count   int default 0,
  created_at     timestamp not null default now()
);

create index idx_places_country on places(country_id);
create index idx_places_geo on places(latitude, longitude);

-- M:N
create table place_subcategories (
  place_id       uuid not null references places(place_id) on delete cascade,
  subcategory_id int  not null references subcategories(subcategory_id) on delete cascade,
  primary key (place_id, subcategory_id)
);

-- Horarios
create table place_hours (
  place_hours_id serial primary key,
  place_id       uuid not null references places(place_id) on delete cascade,
  day_of_week    smallint not null check (day_of_week between 0 and 6), -- 0=Domingo
  open_time      time,
  close_time     time,
  unique (place_id, day_of_week, open_time, close_time)
);

-- Fotos
create table place_photos (
  photo_id   uuid primary key default gen_random_uuid(),
  place_id   uuid not null references places(place_id) on delete cascade,
  url        text not null,
  is_primary boolean not null default false
);

-- 4) Social
create table reviews (
  review_id   uuid primary key default gen_random_uuid(),
  place_id    uuid not null references places(place_id) on delete cascade,
  user_id     uuid not null references app_users(user_id) on delete cascade,
  rating      smallint not null check (rating between 1 and 5),
  comment     text,
  created_at  timestamp not null default now(),
  unique (place_id, user_id)
);

create index idx_reviews_place on reviews(place_id);
create index idx_reviews_user  on reviews(user_id);

create table review_likes (
  review_id  uuid not null references reviews(review_id) on delete cascade,
  user_id    uuid not null references app_users(user_id) on delete cascade,
  created_at timestamp not null default now(),
  primary key (review_id, user_id)
);

create table favorites (
  user_id    uuid not null references app_users(user_id) on delete cascade,
  place_id   uuid not null references places(place_id) on delete cascade,
  created_at timestamp not null default now(),
  primary key (user_id, place_id)
);

create table visits (
  visit_id   uuid primary key default gen_random_uuid(),
  user_id    uuid not null references app_users(user_id) on delete cascade,
  place_id   uuid not null references places(place_id) on delete cascade,
  visited_at timestamp not null default now()
);

-- 5) Itinerarios
create table itineraries (
  itinerary_id uuid primary key default gen_random_uuid(),
  user_id      uuid not null references app_users(user_id) on delete cascade,
  name         varchar(120) not null,
  start_date   date,
  end_date     date,
  notes        text,
  created_at   timestamp not null default now()
);

create index idx_itins_user on itineraries(user_id);

create table itinerary_items (
  item_id        uuid primary key default gen_random_uuid(),
  itinerary_id   uuid not null references itineraries(itinerary_id) on delete cascade,
  place_id       uuid not null references places(place_id) on delete restrict,
  start_datetime timestamp,
  end_datetime   timestamp,
  notes          text,
  order_index    int,
  check (end_datetime is null or start_datetime is null or end_datetime >= start_datetime)
);

-- 6) Trigger rating (corregido y compatible)
create or replace function recompute_place_rating()
returns trigger
language plpgsql
as $func$
declare
  v_place uuid;
begin
  v_place := coalesce(new.place_id, old.place_id);

  update places p
     set avg_rating   = sub.avg_rating,
         review_count = sub.cnt
    from (
      select place_id,
             coalesce(avg(rating), 0)::numeric(3,2) as avg_rating,
             count(*) as cnt
      from reviews
      where place_id = v_place
      group by place_id
    ) sub
   where p.place_id = sub.place_id;

  if not found then
    update places
       set avg_rating = 0.00,
           review_count = 0
     where place_id = v_place;
  end if;

  return null;
end
$func$;

drop trigger if exists trg_reviews_after_change on reviews;

create trigger trg_reviews_after_change
  after insert or update or delete on reviews
  for each row execute function recompute_place_rating();
